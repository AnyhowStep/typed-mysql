import * as mysql from "mysql";
import * as sd from "schema-decorator";
import { PaginationConfiguration, RawPaginationArgs } from "./pagination";
import { ConnectedDatabase } from "./ConnectedDatabase";
import { QueryValues } from "./QueryValues";
import { OrderByItem } from "./OrderByItem";
import { SelectResult, SelectOneResult, SelectZeroOrOneResult, InsertResult, MysqlUpdateResult, UpdateResult, MysqlDeleteResult, SelectPaginatedResult } from "./ConnectedDatabase";
export interface DatabaseArgs {
    host: string;
    database: string;
    charset?: string;
    user: string;
    password: string;
    timezone?: string;
}
export declare function insertUnsafeQueries(query: string, values: any): string;
export declare function createQueryFormatCallback(useUtcOnly: boolean): (query: string, values: any) => string;
export declare class Database {
    private pool;
    private defaultConnection;
    private useUtcOnly;
    allocatePoolConnection(): Promise<mysql.PoolConnection>;
    private allocatingDefaultConnection;
    private onAllocateCallback;
    getOrAllocateDefaultConnection(): Promise<mysql.PoolConnection | ConnectedDatabase>;
    utcOnly(): Promise<void>;
    getDefaultConnection(): ConnectedDatabase;
    getRawConnection(): mysql.Connection;
    constructor(args: DatabaseArgs);
    static InsertUnsafeQueries(query: string, values: any): string;
    readonly queryFormat: (query: string, values: any) => string;
    connect(): Promise<void>;
    rawQuery(queryStr: string, queryValues: QueryValues | undefined, callback: (err: mysql.MysqlError | null, results?: any, fields?: mysql.FieldInfo[]) => void): mysql.Query;
    selectAny(queryStr: string, queryValues?: QueryValues): Promise<SelectResult<any>>;
    select<T>(assert: sd.AssertFunc<T>, queryStr: string, queryValues?: QueryValues): Promise<SelectResult<T>>;
    selectAll<T>(assert: sd.AssertFunc<T>, table: string): Promise<SelectResult<T>>;
    selectOneAny(queryStr: string, queryValues?: QueryValues): Promise<SelectOneResult<any>>;
    selectOne<T>(assert: sd.AssertFunc<T>, queryStr: string, queryValues?: QueryValues): Promise<SelectOneResult<T>>;
    selectZeroOrOneAny(queryStr: string, queryValues?: QueryValues): Promise<SelectZeroOrOneResult<any>>;
    selectZeroOrOne<T>(assert: sd.AssertFunc<T>, queryStr: string, queryValues?: QueryValues): Promise<SelectZeroOrOneResult<T>>;
    static ToEqualsArray(queryValues: QueryValues): string[];
    static ToWhereEquals(queryValues: QueryValues): string;
    static ToSet(queryValues: QueryValues): string;
    static ToOrderBy(orderByArr: OrderByItem[]): string;
    static ToInsert(queryValues: QueryValues): {
        columns: string;
        keys: string;
    };
    insertAny<T extends QueryValues>(table: string, row: T): Promise<InsertResult<T>>;
    insert<T extends QueryValues>(assert: sd.AssertFunc<T>, table: string, row: T): Promise<InsertResult<T>>;
    rawUpdate(queryStr: string, queryValues: QueryValues): Promise<MysqlUpdateResult>;
    updateAny<T extends QueryValues, ConditionT extends QueryValues>(table: string, row: T, condition: ConditionT): Promise<UpdateResult<T, ConditionT>>;
    update<T extends QueryValues, ConditionT extends QueryValues>(assertRow: sd.AssertFunc<T>, assertCondition: sd.AssertFunc<ConditionT>, table: string, row: T, condition: ConditionT): Promise<UpdateResult<T, ConditionT>>;
    updateByNumberId<T extends QueryValues>(assert: sd.AssertFunc<T>, table: string, row: T, id: number): Promise<InsertResult<T>>;
    rawDelete(queryStr: string, queryValues?: QueryValues): Promise<MysqlDeleteResult>;
    delete(table: string, queryValues: QueryValues): Promise<MysqlDeleteResult>;
    getAny(queryStr: string, queryValues?: QueryValues): Promise<any>;
    get<T>(assertion: sd.AssertDelegate<T>, queryStr: string, queryValues?: QueryValues): Promise<T>;
    getBoolean(queryStr: string, queryValues?: QueryValues): Promise<boolean>;
    getNumber(queryStr: string, queryValues?: QueryValues): Promise<number>;
    getNaturalNumber(queryStr: string, queryValues?: QueryValues): Promise<number>;
    getString(queryStr: string, queryValues?: QueryValues): Promise<string>;
    getDate(queryStr: string, queryValues?: QueryValues): Promise<Date>;
    exists(table: string, queryValues: QueryValues): Promise<boolean>;
    now(): Promise<Date>;
    static Escape(raw: any, toUTCIfDate?: boolean): string;
    static EscapeId(raw: string): string;
    getArrayAny(queryStr: string, queryValues?: QueryValues): Promise<any[]>;
    getArray<T>(assertion: sd.AssertDelegate<T>, queryStr: string, queryValues?: QueryValues): Promise<T[]>;
    getBooleanArray(queryStr: string, queryValues?: QueryValues): Promise<boolean[]>;
    getNumberArray(queryStr: string, queryValues?: QueryValues): Promise<number[]>;
    getNaturalNumberArray(queryStr: string, queryValues?: QueryValues): Promise<number[]>;
    getStringArray(queryStr: string, queryValues?: QueryValues): Promise<string[]>;
    getDateArray(queryStr: string, queryValues?: QueryValues): Promise<Date[]>;
    beginTransaction(): Promise<{}>;
    rollback(): Promise<{}>;
    commit(): Promise<{}>;
    getPaginationConfiguration(): {
        defaultPage: number;
        maxItemsPerPage: number;
        minItemsPerPage: number;
        defaultItemsPerPage: number;
    };
    setPaginationConfiguration(paginationConfiguration: PaginationConfiguration): void;
    selectPaginated<T>(assert: sd.AssertFunc<T>, queryStr: string, queryValues?: QueryValues, rawPaginationArgs?: RawPaginationArgs): Promise<SelectPaginatedResult<T>>;
    simpleSelectZeroOrOne<T>(assert: sd.AssertFunc<T>, table: string, queryValues?: QueryValues): Promise<SelectZeroOrOneResult<T>>;
    simpleSelectOne<T>(assert: sd.AssertFunc<T>, table: string, queryValues?: QueryValues): Promise<SelectOneResult<T>>;
    simpleSelectPaginated<T>(assert: sd.AssertFunc<T>, table: string, orderBy: OrderByItem[], queryValues?: QueryValues, rawPaginationArgs?: RawPaginationArgs): Promise<SelectPaginatedResult<T>>;
    escape(raw: any): void;
    isUtcOnly(): boolean;
    transaction(callback: (db: ConnectedDatabase) => Promise<void>): Promise<void>;
}
